const mockEvent = { body: JSON.stringify({ prompt: 'Hello, world!', parameters: { max_new_tokens: 256, temperature: 0.1 } }) }; const mockContext = {}; const mockInvokeEndpoint = jest.spyOn(smr_client, 'invoke_endpoint').mockReturnValue({ Body: { read: () => JSON.stringify({ result: 'Hello, world! This is a test response.' }) } }); const mockGetEnv = jest.spyOn(process, 'env', 'get').mockReturnValue('test-endpoint'); const result = await lambda_handler(mockEvent, mockContext); expect(result).toEqual({ statusCode: 200, body: JSON.stringify({ result: 'Hello, world! This is a test response.' }) }); mockInvokeEndpoint.mockRestore(); mockGetEnv.mockRestore();

const mockEvent = { body: JSON.stringify({ parameters: { max_new_tokens: 256, temperature: 0.1 } }) }; const mockContext = {}; const result = await lambda_handler(mockEvent, mockContext); expect(result).toEqual({ statusCode: 400, body: JSON.stringify({ error: 'Invalid input: prompt is required' }) });

const mockEvent = { body: JSON.stringify({ prompt: 'Hello, world!', parameters: { max_new_tokens: 256, temperature: 0.1 } }) }; const mockContext = {}; const mockInvokeEndpoint = jest.spyOn(smr_client, 'invoke_endpoint').mockRejectedValue(new Error('SageMaker Runtime error')); const mockGetEnv = jest.spyOn(process, 'env', 'get').mockReturnValue('test-endpoint'); const result = await lambda_handler(mockEvent, mockContext); expect(result).toEqual({ statusCode: 500, body: JSON.stringify({ error: 'SageMaker Runtime error' }) }); mockInvokeEndpoint.mockRestore(); mockGetEnv.mockRestore();

